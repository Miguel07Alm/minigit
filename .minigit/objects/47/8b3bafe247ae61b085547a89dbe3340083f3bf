use std::{
    fs,
    path::{Path, PathBuf},
};

use sha1::{Digest, Sha1};
pub fn hash_object(data: &[u8], obj_type: &str) -> String {
    let mut hasher = Sha1::new();
    hasher.update(format!("{} {}\0", obj_type, data.len()).as_bytes());
    hasher.update(data);
    hex::encode(hasher.finalize())
}
pub fn process_entry(entry: &Path) {
    if entry.is_dir() {
        println!("{:?} is a directory. Entering directory.", entry);
        match fs::read_dir(entry) {
            Ok(sub_entries) => {
                for sub_entry in sub_entries {
                    match sub_entry {
                        Ok(sub_entry) => process_entry(&sub_entry.path()),
                        Err(err) => eprintln!("Error reading subdirectory: {}", err),
                    }
                }
            }
            Err(err) => eprintln!("Error reading directory: {}", err),
        }
    } else {
        let content = match fs::read(entry) {
            Ok(content) => content,
            Err(err) => {
                eprintln!("Failed to read file {:?}: {}", entry, err);
                return;
            }
        };

        let hash = hash_object(&content, "blob");
        println!("hash: {}", &hash);

        let dir_path = format!(".minigit/objects/{}", &hash[0..2]);
        println!("dir_path: {}", &dir_path);

        let file_path = format!("{}/{}", dir_path, &hash[2..]);
        println!("file_path: {}", &file_path);

        if !Path::new(&file_path).exists() {
            match fs::create_dir_all(&dir_path) {
                Ok(_) => {}
                Err(err) => {
                    eprintln!("Failed to create directories {}: {}", dir_path, err);
                    return;
                }
            }

            match fs::write(&file_path, &content) {
                Ok(_) => {}
                Err(err) => {
                    eprintln!("Failed to write object {}: {}", file_path, err);
                    return;
                }
            }
        }

        println!("Added file {} to index with hash {}", entry.display(), hash);
    }
}
